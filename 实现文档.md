# 1修改SDK
1. 使用UltraEdit或者其他16进制修改工具，打开libWeWorkFinanceSdk_Java.so
2. 搜索企微域名https://qyapi.weixin.qq.com  将其修改为**同等长度**的域名(我这里改成了k8s svc 名称)
# 2部署openresty
官方提供的镜像就可以使用，需要如下修改
1. 提供dns解析配置
  ```
  http {
  resolver 10.252.0.10(coredns ip) valid=5 ipv6=off;
  }
  ```
3. 添加优化配置
  ```
  http {
  client_header_buffer_size 2046k;
  large_client_header_buffers 4 2046k;
  client_max_body_size 500M;
  client_body_buffer_size 100M;
  lua_shared_dict crop_id 10m;
  }
  ```
3. 添加init map文件(corpid和上游nginx关系)
  ```
  格式为
  "cropid" "qywx-svc1";
  "cropid" "qywx-svc2";
  ```
  ```
  http {
  init_by_lua_file '/usr/local/openresty/nginx/lua/init_map.lua';
  }
  ```
4. 增加server块
```
# 新增 给会话存档用
server {
    listen 80;
    server_name <SDK中修改好的域名>;
    set $wx_crop_id "hhcd";
    set $wx_upstream "https://qyapi.weixin.qq.com";
    set $wx_host "qyapi.weixin.qq.com";
    location = /cgi-bin/gettoken {
        # 请求gin
        default_type text/html;
        proxy_pass http://127.0.0.1:8080;
    }
    location / {
        default_type text/html;
        proxy_set_header Host $wx_host;
        access_by_lua_file '/usr/local/openresty/nginx/lua/getredis.lua';
        proxy_pass $wx_upstream;
    }
    location /health {
        return 200 'ok';
    }
}
server {
    listen 80 default;  # 这里是java主动发起的所以
    set $wx_crop_id "";
    set $wx_upstream "https://qyapi.weixin.qq.com";
    set $wx_host "qyapi.weixin.qq.com";
    location = /cgi-bin/gettoken {
        default_type text/html;
        access_by_lua_file '/usr/local/openresty/nginx/lua/get_token.lua';
        proxy_set_header Host $wx_host;
        proxy_pass $wx_upstream; 
    }
    location / {
        default_type text/html;
        access_by_lua_file '/usr/local/openresty/nginx/lua/getredis.lua';
        proxy_set_header Host $wx_host;
        proxy_pass $wx_upstream;
    }
    location /health {
      log_not_found off;
      access_log off;
      return 200 'ok';
    }
}
```
6. lua脚本
init_map.lua
```
local cjson = require("cjson")
  local function load_map(file_path)
      local map = {}
      local file = io.open(file_path, "r")

      if not file then
          ngx.log(ngx.ERR, "Failed to open map file: ", file_path)
          return map
      end

      for line in file:lines() do
          local key, value = string.match(line, [["(%S+)"%s+"(%S+)";]])
          if key and value then
              map[key] = value
          end
      end

      file:close()
      return map
  end

local map_file_path = "/usr/local/openresty/nginx/cropid/cropid_map.map"
local tmp = load_map(map_file_path)
ngx.shared.crop_id:set("a", cjson.encode(tmp))
local keys = ngx.shared.crop_id:get("a")
io.stderr:write("\n---------------------------------\n")
io.stderr:write("JSON: ", keys, "\n")
```
getredis.lua
修改redis信息和选择的db
```
local redis = require("resty.redis");
local cjson = require("cjson")
local red = redis:new();
red:set_timeout(5000)
local host = "<redis域名>"
local port = 6379
local redis_username = "<用户名>"
local redis_password = "<密码>"
local access_token = ngx.var.arg_access_token

local function ret_def()
    ngx.var.wx_upstream = "https://qyapi.weixin.qq.com"
    ngx.var.wx_host = "qyapi.weixin.qq.com"
    ngx.var.wx_crop_id = "no"
end

if type(access_token) == "nil" then
    ret_def()
    return
end
local keys = 'qwtoken:' .. access_token

-- 连接redis
local ok, err = red:connect(host, port)
if not ok then
  io.stderr:write('cant connect redis\n')
  ret_def()
  return
end

local res, err = red:auth(redis_username, redis_password)
if not res then
  io.stderr:write('cant auth redis\n')
  return
end

-- 选择db
ok, err = red:select(<redisDB>)
if not ok then
    io.stderr:write('failed to select db\n')
    ret_def()
    return
end

-- 获取redis key
local res, err = red:get(keys)
if not res then
  io.stderr:write('cant get redis\n')
  ret_def()
  return
end

ok, err = red:set_keepalive(10000, 300) --线程池
if not ok then
  io.stderr:write('cant close redis\n')
  ret_def()
  return
end
-- 将string转为map
local keys = ngx.shared.crop_id:get("a")
local my_table = cjson.decode(keys)
local value = my_table[res]

if value then
    ngx.var.wx_crop_id = res
    ngx.var.wx_upstream = "http://" .. value .. ".<命名空间>.svc.cluster.local:20000"
    ngx.var.wx_host = "qyapi.weixin.qq.com"
    -- 后续的服务会加这个HOST
else
    ret_def()
end
```
get_token.lua
```
-- 获取corpid参数并判断wx_upstream地址
local cjson = require("cjson")
local req_corpid = ngx.var.arg_corpid
io.stderr:write("request_corpid: ", req_corpid, "\n")
-- 将crop_id string转为map
local keys = ngx.shared.crop_id:get("a")
-- ngx.log(ngx.INFO, "Decoded table: ", (keys))
-- 序列化
local my_table = cjson.decode(keys)
-- 取对应req_corpid的值
local value = my_table[req_corpid]
if value then
  ngx.var.wx_crop_id = req_corpid
  -- 如果写域名后路径, 需要在proxy_pass后添加$is_args$args传递请求参数
  -- 这里需要写全FQDN
  ngx.var.wx_upstream = "http://" .. value .. ".<命名空间>.svc.cluster.local:20000"
end
```
